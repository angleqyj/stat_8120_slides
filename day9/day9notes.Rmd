---
title: "Day 9"
author: "Taylor R. Brown"
date: "12/13/2019"
output: slidy_presentation
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```


## Resampling

Resampling:

-  is a computational bottleneck. 
    * it prevents parallelization, and 
  
    * it is more computationally intensive than sampling

- pretty much takes care of weight degeneracy, but it adds noise to our approximations


- resampling, also causes **sample impoverishment** (but we won't discuss this)


That's why a lot of work has gone into alternative ways to resample. Alternatives will usually address one of these two issues.


## Multinomial Resampling

**Multinomial resampling** is the most common way to resample. 

For any time point $k$, resample $\{\xi_k^j\}_{j=1}^N$ from $\{\tilde{\xi}_k^i\}_{i=1}^N$ by drawing indexes $I_k^j$. 

$$
\mathbb{P}(I_k^j = i \mid \mathcal{G}) = \frac{\omega_k^i }{\sum_{l=1}^N \omega_k^l } \propto \omega_k^i
$$
where $\mathcal{G}$ is the sigma field generated by 
$$
\omega_k^1, \ldots, \omega_k^N
$$
and
$$
\tilde{\xi}_k^1, \ldots, \tilde{\xi}_k^N
$$


## Multinomial Resampling

Common confusion:

- sometimes people talk about drawing indexes

- sometimes people talk about drawing counts

Both could be considered multinomial random variables, but we are referring to indexes now.


## Programming

For some, programming particle filters is easier than understanding the mathematical notation. 

In most languages, it is possible to resample each particle without even making reference to its index.

I'll discuss a few implementations in `R`, `Python` and `c++`


## In `R`

Something like this...
```{r,eval=F, echo=T}
sample(x_tildes, 
       length(x_tildes), 
       replace = TRUE, # need to be with replacement 
       prob = unnormalized_updated_weights) # normalization is automatically done by the function :)
```


## In `Python`

Something like this...
```{python, eval=F,echo=T}
import numpy as np
np.random.choice(x_tildes, 
                 len(x_tildes), 
                 replace=True, 
                 unnormalized_updated_weights # not sure if you have to divide by the sum or not
                 )
```


## In `c++`


In [pf](https://github.com/tbrown122387/pf/blob/master/include/sisr_filter.h) I use an object-oriented approach
```{c, echo=T, eval=F}
m_resampler.resampLogWts(m_particles, m_logUnNormWeights);
```



## Optional: section 7.4.1

If you're going for speed, you're probably going to go down the resampling rabbit hole at least a little.

Section 7.4.1 describes some of the lower-level details of turning uniform random numbers into indexes.

In our mathematical statistics courses, we usually discuss the **inversion method**. If $U \sim \text{Uniform}(0,1]$, then 
$$
X \overset{\text{def}}{=} F_X^{-1}(U) \sim F_X
$$

Many (most?) pseudo-random number generator functions use this approach!

## Optional: section 7.4.1

What is the inverse cdf of $\mathbb{P}(I_k^j = i \mid \mathcal{G})$?

Recall that $F^{-1}(p) = \text{inf}\{ i  : F(i) \ge p \}$.


## Optional: section 7.4.1

What is the inverse cdf of $\mathbb{P}(I_k^j = i \mid \mathcal{G})$?

Recall that $F^{-1}(p) = \text{inf}\{ i  : F(i) \ge p \}$.

It's the $I$ such that 
$$
\sum_{j=1}^{I-1} \tilde{\omega}_k^j < I \le \sum_{j=1}^{I} \tilde{\omega}_k^j
$$
where $\tilde{\omega}$ are the **normalized** weights.


## Optional: section 7.4.1

They talk about some cool strategies for reducing the number of steps it takes to figure out the $I$ from the previous slide. 

- pre-sorting your uniform samples will allow you to perform fewer comparisons, but 
- sorting is also computationally demanding. 

Summary: the book discusses some old theorems to help generate **ordered** uniform random variables with having to use a traditional sorting algorithm at all!

Note, even in low-level compiled languages like c++, you [don't have to get into this](https://en.cppreference.com/w/cpp/numeric/random/discrete_distribution) ([my implementation](https://github.com/tbrown122387/pf/blob/515cb7f94fcd5ca13a12095af35bdee8412320a5/include/resamplers.h#L105).)